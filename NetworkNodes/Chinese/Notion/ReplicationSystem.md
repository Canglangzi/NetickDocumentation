# Replication System

## 一、核心概念定义

### 1.  Networking（网络同步

指通过网络连接实现多个独立设备间的实时数据交换和状态同步，使分布式用户能在共享虚拟环境中交互的技术体系。在Unity中特指实现多人联机游戏的技术解决方案。

网络工作流

### 2.  网络工作流

指数据在网络中从发送端到接收端的完整处理流程，包含**连接管理、数据封装、传输、解析**等步骤。无论是早期底层开发还是现代高层框架，核心目标始终是：**可靠、高效、安全地传输数据**。

### 二. Replication System

在多人在线游戏中，复制系统（Replication System）是确保所有客户端与服务器保持状态同步的核心机制。它负责将游戏对象的状态（如玩家位置、血量、道具状态等）高效、可靠地传播到所有相关客户端。

一致性：所有客户端看到的游戏世界状态与服务器权威版本保持一致。

低延迟：最小化玩家操作到可视反馈的时间（通常要求<150ms）。

带宽效率：在有限网络条件下传输必要数据，如《Apex英雄》仅使用20-60KB/s带宽。

容错性：应对丢包、抖动等网络问题，防止同步断裂。 

+---------------------+
| 游戏逻辑层           |  // 生成状态变更事件
+---------------------+
          |
+---------------------+
| 复制管理层           |  // 决定同步对象、频率、方式
+---------------------+
          |
+---------------------+
| 网络传输层           |  // 数据序列化、压缩、传输
+---------------------+ 

## 同步方式

 状态同步（State Synchronization）
原理：服务器定期向客户端发送游戏对象的完整或增量状态。

实现方式：

快照同步（Snapshot）：
服务器以固定频率（如30Hz）发送完整世界状态。
案例：《Quake III》使用10Hz快照，客户端通过插值平滑过渡。

Delta压缩：
仅发送与前一次快照的差异数据，节省30-70%带宽。
优化：采用位掩码标记变更字段，如Unreal Engine的RepNotify。

## 远程调用

 远程过程调用（RPC）
作用：同步瞬时事件（如开枪、技能释放）。

类型：

可靠RPC：确保到达，用于关键事件（如伤害计算）。

不可靠RPC：允许丢失，用于高频非关键事件（如脚步声）。

## 预测与校正

 预测与校正（Prediction & Reconciliation）
客户端预测（Client-side Prediction）：
立即响应本地操作，无需等待服务器确认。
实现：维护一个操作历史缓冲区，典型深度5-10帧。

服务器校正（Server Reconciliation）：
当服务器状态到达时，回滚并重演预测帧。

动态优先级：
根据对象重要性分配带宽，例如：

玩家角色：优先级10

远处NPC：优先级2

静态场景物体：优先级0（不更新）

相关性过滤：
只同步客户端可见/可交互的对象，如《绝地求生》中：

1km内玩家同步位置

500m内同步详细动作

100m内同步子弹轨迹 

## 1.High-Level Networking 复制系统介绍

**复制系统** 是一套全局策略，用于在分布式环境中高效、可靠地同步游戏状态。其核心目标并非“简单地让玩家看到相同画面”，而是：

1. **抗丢包**：在 10%~30% 丢包率下仍保持流畅体验。
2. **低带宽**：通过压缩和增量更新减少数据量。
3. **低延迟**：优先同步关键数据，减少传输延迟影响。
4. **状态收敛**：即使发生丢包，客户端最终也能收敛到正确状态。

**常见误区**：

- **“可靠传输 = 复制系统”**：直接依赖 TCP 或可靠 UDP（如 ENET）会导致以下问题：
- 重传过时数据（如已淘汰的中间状态）。
- 累积确认机制引发“队头阻塞”（Head-of-Line Blocking）。
- 无法针对游戏数据类型优化（如位置 > 特效优先级）。

## 2.带宽问题

以UNet FishNet Netcode **Mirror** 为例，其同步逻辑直接调用底层传输的三种模式：

1. **不可靠发送**（Unreliable）：不保证到达，适用于非关键数据（如粒子特效）。
2. **可靠有序**（Reliable Ordered）：保证按顺序到达，但重传旧数据阻塞通道。
3. **可靠无序**（Reliable Unordered）：保证到达但不保序，适合独立事件（如得分）。

**问题根源**：

- **无状态快照管理**：每次同步变量时，框架直接调用可靠传输发送全量数据，而非增量更新。
- **队头阻塞效应**：若某个旧数据包丢失，后续所有数据需等待重传，即使它们已过时。
- **带宽浪费**：频繁发送中间状态（如角色移动路径上的每帧位置），而非最终目标位置。

**示例对比**：

角色从 A 移动到 B

Mirror流程如下

发送 A→A1→A2→B 

所有中间位置仅发送 B 的最终位置

Netick UE Photon

仅发送 B 的最终位置

直接发送最新 B，忽略旧数据

## 1.Delta 快照（Delta Snapshots）

- 服务器维护一个完整游戏状态快照（Snapshot）。
- 每次同步时，计算当前快照与客户端已确认快照的差异（Delta）。
- **仅发送差异部分**，并附带序列号（Sequence ID）标识快照版本。

即使连续丢包，客户端最终会收到完整快照

总结：在 Delta 快照中，我们编码整个网络游戏状态的完整快照与客户端所拥有的状态进行对比，因此我们自动对抗数据包丢失，因为我们始终发送尚未确认的所有内容。

## **2. 最终一致性（Eventual Consistency）**

**原理**：

- 每个网络变量（如玩家血量）独立同步，标记为“脏”（Dirty）时发送更新。
- 若未收到确认，则在下一周期**重传最新值**（非历史值）。
- 允许短暂不一致，但最终所有客户端收敛到相同状态。

**优势**：

- **低开销**：无需维护全局快照，适合大量动态对象场景。
- **弹性传输**：非关键数据可允许丢包（如环境特效）。

总结：在最终一致性中，我们为网络数据发送一次或两次更改，并且只有在确认丢失时才重新发送。在丢失期间，这比 Delta 快照效果更差，但它仍然比简单地使用可靠有序选项发送事物要好，因为我们只重新发送网络变量的最新状态，而不是所有中间值。.

第一种方法被 CSGO、Overwatch、Quake 和许多 AAA 游戏所使用。

第二个被虚幻引擎网络和光环使用。

## 资料：

**《CS:GO 网络架构详解》**（Valve 开发者博客）

```javascript
https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking
```

**《守望先锋》网络同步 GDC 演讲**

```javascript
https://www.youtube.com/watch?v=W3aieHjyNvw
```

```javascript
https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-5-0-documentation?application_version=5.0
```