# 前言：

我是Mirror 转到fishnet 又转到Nettick 我使用的理由是 我需要制作服务器权威的FPS防止作弊 放弃mirror 没有预测（现在有不知道使用情况）fishnet有预测  但是当时预测功能不太完善 示例都跑不起来 我现在转到netick用二百行代码就可以实现预测 我将从头到尾描述网络联机工作流在Unity 不选择photon的理由当然是昂贵的收费政策 ，自由度不行

有的人说多人游戏对于独立游戏来说很难，但是在hight网络框架下其实他能变得很简单

多人游戏的核心，就是每台电脑各自运行着独立的本地模拟，再通过网络互相传递关键数据而已。所谓服务器，本质上也就是一台运行着特定逻辑的电脑。

## 一 你的电脑就是你的世界：

- 无论你使用 Unity 还是 Unreal，当你的角色在游戏世界里奔跑、跳跃、射击时，**这一切首先发生在你自己的电脑上**。游戏引擎在你的本地内存中维护着整个游戏世界的状态（至少是你视野范围内的部分）。

- 物理计算、动画播放、输入响应、特效渲染……所有这些“感觉”即时发生的动作，**都是你的本地机器在实时模拟**。引擎不会每帧都去问服务器“我现在该站在哪里？”。

## 二 网络：数据的搬运工

- 网络层（无论是 Unity 的 Netcode/UNet/Mirror 还是 Unreal 的 Replication/RPC）扮演的角色，就是一个**勤快的快递员**。

- **服务器（另一台电脑）的职责：**
  
  - **运行权威模拟：** 它运行着游戏的“唯一真相”版本。它决定规则（比如这个技能打中了吗？这个门能开吗？）、处理核心逻辑、计算最终结果。
  
  - **收集与分发：** 收集所有客户端（玩家电脑）发送过来的操作指令（如“我按了W键”、“我点击了鼠标左键”），然后根据权威模拟的结果，计算出**世界状态的变化**（如玩家A的新位置、玩家B的血量减少、炸弹爆炸了）。
  
  - **派发数据包：** 将这个“权威的世界状态快照”或“状态变化增量”打包，通过“快递员”（网络）发送给所有相关的客户端。

- ## 三 你的电脑（客户端）的职责：
  
  - **发送操作：** 把你本地的操作（按键、鼠标移动、技能释放请求）打包发送给服务器。**注意：你按下键的瞬间，角色可能已经在本地移动了（预测），但这需要服务器最终确认。**
  
  - **接收更新：** 接收服务器发来的“快递包裹”（网络数据包），里面装着服务器确认的世界状态。
  
  - **应用更新：** **最关键的一步！** 解析收到的数据包，用里面的数据**更新你本地的游戏世界状态**。例如：
    
    - 将服务器发来的其他玩家的新位置、旋转应用到他们对应的本地模型上。
    
    - 更新服务器发来的你自己的血量（可能和本地预测的不同，需要修正）。
    
    - 在服务器指定的位置生成一个爆炸特效。
  
  - **本地预测与插值：** 为了让你感觉游戏流畅（即使网络有延迟），客户端会：
    
    - **预测 (Prediction)：** 在你按下移动键时，不等服务器回复，先在本地移动你的角色。如果服务器回复的位置和你预测的不同，再进行**位置修正**（可能表现为角色“瞬移”一小下）。
    
    - **插值 (Interpolation)：** 对于其他移动的物体（如其他玩家、NPC），不会直接跳到服务器发来的最新位置，而是在两个已知位置之间进行平滑过渡，避免“抖动”。

## **简单流程示例（通用）：**

1. **玩家A (Client)：** 按下 “W” 键向前移动。

2. **玩家A本地：** 立刻根据输入移动角色（预测）。

3. **玩家A客户端：** 发送一个 `Command/MoveRequest` (RPC) 给服务器：“玩家A请求向前移动”。

4. **服务器：** 收到请求，进行权威验证（是否合法？有障碍物？）。计算玩家A的新位置。

5. **服务器：** 更新其权威世界状态中的玩家A位置。

6. **服务器：** 将玩家A的新位置信息打包，通过“快递”发送给所有客户端（包括玩家A自己）。

7. **玩家B (Client)：** 收到服务器数据包，解析出玩家A的新位置。

8. **玩家B本地：** **应用数据！** 将玩家A的游戏对象移动到新位置（可能平滑插值过渡）。

9. **玩家A (Client)：** 也收到服务器发来的自己位置更新。对比本地预测的位置：
   
   - 如果一致：万事大吉。
   
   - 如果不一致（比如服务器检测到撞墙了）：**应用服务器数据！** 将自己的角色位置**修正**到服务器发来的位置（可能产生小的“回退”）。
- **核心思想确实简单：** 本地模拟 + 网络收发数据 + 应用数据 = 多人游戏的基础。服务器就是运行核心逻辑的那台电脑。

- **实现细节充满挑战：** “简单”不等于“容易”。如何高效压缩数据？如何应对网络延迟（Lag）和抖动（Jitter）？如何设计公平的预测和补偿（Reconciliation）？如何防止作弊？如何同步大量动态物体？如何处理断线重连？如何设计网络拓扑（专用服务器、监听服务器、P2P）？这些才是真正的难点，也是区分网络实现好坏的关键。

- **引擎的作用：** Unity 和 Unreal 提供的网络框架，就是为了解决这些“魔鬼细节”，提供一套相对可靠、高效的通信机制（如 RPC、状态同步、对象生成/销毁同步、预测和插值工具等），让开发者不必从最底层的 Socket 通信开始造轮子，能更专注于游戏逻辑本身。

应用层面

# Unity vs Unreal：工作流实现对比

| 特性       | Unity (常用方案：Netcode for GameObjects / Mirror)                                                         | Unreal Engine (内置网络框架)                                                                                             |
| -------- | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| **核心模型** | 更灵活。可选择权威服务器(`ServerRpc`/`ClientRpc`)，也支持点对点(P2P)。常用 `Server` 权威模型。                                   | **强制的权威服务器模型**。服务器是唯一真相源，客户端只能复制状态/调用RPC。                                                                          |
| **状态同步** | **需要显式定义同步变量：** 使用 `[NetworkVariable]` (Netcode) 或 `[SyncVar]` (Mirror) 标记需自动同步的变量。修改在服务器生效，自动同步到客户端。 | **自动复制：** 使用 `Replicated` 属性标记变量。变量在服务器改变，引擎自动同步到相关客户端。**粒度控制更细**。                                                 |
| **远程调用** | **RPC (Remote Procedure Call)：**<br>`ServerRpc`: 客户端 -> 服务器调用。<br>`ClientRpc`: 服务器 -> 客户端调用。          | **RPC (Remote Procedure Call)：**<br>`Server` 函数：客户端 -> 服务器调用。<br>`Client` 或 `NetMulticast` 函数：服务器 -> 客户端(单个/多个)调用。 |
| **对象生成** | **需网络生成：** 使用 `NetworkManager.Spawn` (Netcode) 或 `NetworkServer.Spawn` (Mirror) 在服务器生成，自动同步到客户端。      | **需网络生成：** 使用 `SpawnActor` 及相关网络参数在服务器生成，自动复制到客户端。                                                                 |
| **预测核心** | **需手动实现或依赖库：** Netcode 提供基础网络Transform组件，复杂预测(如射击判定)需自行处理或使用第三方方案。                                    | **内置强大预测支持：** `Ability System` (GAS) 对技能预测有良好支持。`CharacterMovementComponent` 内置移动预测。                               |
| **网络拓扑** | 灵活支持 Dedicated Server, Listen Server, P2P。                                                            | 主要优化 Dedicated Server 和 Listen Server。P2P支持较弱。                                                                     |
