<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Prediction in-depth | Netick Networking Engine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Prediction in-depth | Netick Networking Engine ">
      
      <link rel="icon" href="../images/logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Netick Docs | v2">
            Netick Docs | v2
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="prediction-in-depth">Prediction in-depth</h1>

<p>Before diving in, let's do a recap on what prediction means.</p>
<p>Prediction is the act of the client to predict what the game (the networked state of the game) looks like in the server, starting from the latest received server snapshot as a baseline. The client uses its local inputs that have yet to be acknowledged and processed by the server to simulate up to the time difference between it and the server, so that the client sees the same state as the server, at almost the same time. From the perspective of the client, prediction means predicting the future state of the server, since to the client, due to RTT, the server is in the future.</p>
<p>However, for many types of games, namely First Person Shooters, we only predict one or a few more objects, notably our own local player character.</p>
<p>When we do this, our local player character object will live in the local (predicted) timeline. While remote objects (including remote players) will live in the remote timeline. What do we mean by these terms?</p>
<ul>
<li><p>Remote Timeline: Remote Timeline refers to the delayed (by half RTT) timeline we see proxy objects in the client. A proxy object is any object that the client is not providing inputs to (not an Input Source of), and is fully controlled by the server, and the client merely observes the incoming server state snapshots for it. Because the server data is delayed, what we see for these objects is delayed by <code>half RTT + interpolation delay</code>.</p>
</li>
<li><p>Local/Predicted Timeline: Local/Predicted refers to the timeline predicted objects in the client live in. The local timeline differs to the remote timeline by being ahead of the remote timeline by <code>RTT + additional buffering</code> (due to adaptation to non-ideal network conditions).</p>
</li>
</ul>
<p>What we understand here is that there is a discrepancy. Some objects will be in the local timeline, and others will be in the remote timeline. The remote timeline is out-of-sync with the local timeline. Even though this might seem bad, but that's how almost every First Person Shooter works. The local player in an FPS game is in the predicted timeline, while other players (remote players) are in the remote timeline. Why is that though? Why not put all objects in the predicted timeline for an FPS game?</p>
<p>The problem with this is that, usually, the acceleration speeds of an FPS character are too fast that the prediction will always be wrong, and it results in a poor gameplay experience. You will see a player come out of a corner and suddenly disappear, due to mis-predictions.</p>
<p>An important fact to emphasize is that it's impossible for the client to correctly predict remote/proxy objects. It will keep mis-predicting. This is because it's not possible for the client to predict the input of other clients, due to latency.</p>
<p>But, does this mean remote prediction is bad? No. For many types of games, remote prediction offers a better gameplay experience than putting every other object (except the local player) in the remote timeline. Notably anytime you want to do comprehensive interactions (mostly physical interactions) between players and the environment, remote prediction will result in a better experience. This is because, without prediction, if you were to collide with a remote object, you will only see the effect of the collision by RTT time. Physics-based games, fighting games, and racing games are all examples of games where predicting remote objects is a better strategy.</p>
<p>By default, Netick only predicts objects that the client is the Input Source of. To understand what it means to predict remote/proxy objects, let's explore an example.</p>
<figure><img src="../../images/proxy-prediction.png" alt="Client-Side Prediction"><figcaption></figcaption></figure>
<p>In Rocket Cars, we not only predict the local car, but also the other (remote) cars and the ball. Now, let's see what that means, and also let's see what happens when we don't do that.</p>
<p>Look at the previous image. In this scenario, we assume that each car starts moving at the exact same time. Let's also assume that the cars were moving at the same exact speed for some time, and we are looking at what they look like after that amount of time. In addition, let's say that the ball was also moving in the same direction as the cars. Therefore, all the objects in this scenario are moving, and at the same direction.</p>
<p>In the right-side figure, we see that all cars are aligned with each other, which is what we expect if they started moving at the exact same time and at the exact same speed. Everything looks correct. This is because the clients are not changing their inputs, so the input prediction is correct. But this is usually not the case in practice. However, this shows that prediction will converge to the correct state if the clients are not changing their inputs too much.</p>
<p>Now, let's see what the game looks like if we didn't predict remote/proxy objects. Let's look at the left-side figure above. What we see here is that, now, only our local car is in the predicted position. Other cars are, to us, delayed. The gray ghost shapes show where the cars should be, if they were to be predicted. The difference in position here is the amount of positional discrepancy between the local/predicted timeline against the remote timeline, which is proportional to RTT/latency.</p>
<p>So, the conclusion here is that neither approach is perfect. Not predicting remote objects will result in delayed collisions. Predicting them will result in mis-predictions.</p>
<p>But, for this game, the better approach is to predict remote objects. Therefore, it's a matter of choosing which approach works better for a particular game.</p>
<h2 id="predicting-remoteproxy-objects">Predicting Remote/Proxy Objects</h2>
<p>Now, let's see how we can actually predict remote objects, in practice. Using Netick, this is quite simple. Simply change the <code>Prediction Mode</code> of an object to be equal to <code>Everyone</code> in the inspector. This will cause the <code>NetworkFixedUpdate</code> of this object to execute multiple times due to resimulation.</p>
<p>However, this is not all. To be able to predict the input of other players, we need to sync their inputs. The following code snippet is taken from Rocket Cars.</p>
<pre><code class="lang-cs">  [Networked] public GameInput   LastInput  { get; set; } // We sync the last input for the player. So we can use it to predict remote players cars.
  public override void NetworkFixedUpdate()
  {
    if (FetchInput(out GameInput input))
      LastInput          = input;

    // clamp movement inputs
    input.Movement       = new Vector3(Mathf.Clamp(input.Movement.x, -1f, 1f), Mathf.Clamp(input.Movement.y, -1f, 1f), Mathf.Clamp(input.Movement.z, -1f, 1f));
    SimulateVehicle(input);
  }
</code></pre>
<p>That's all there is to it. <code>FetchInput</code> only returns true on the Input Source itself, and the server. So, by simply defining a network property to store the input in, we are able to sync the input to everyone, including observing (proxies) players.</p>
<p>Notice that we don't actually try to predict the input, we simply use the last input for prediction. Because predicting that the client pressed something it never did is a lot worse than simply assuming the client is still pressing the same buttons.</p>
<p>Rocket Cars serves as an excellent example of how Proxy/Remote Prediction works.</p>
<h2 id="prediction-error-correction-smoothing">Prediction Error Correction Smoothing</h2>
<p>By default, correcting mis-predictions is instantaneous. This will cause the predicted remote objects to snap somewhere else when a player changes their movement direction suddenly. And as we said, the magnitude of mis-predictions is proportional to latency. Therefore, for a smooth visual experience. we must smooth out the prediction correction. Netick impalements a smooth correcter in <code>NetworkTransfrom</code>/<code>NetworkRigidbody</code>. By enabling it, it will smooth out the corrections over multiple frames. There are a few settings for it which will need to be fine-tuned to find what is best for your object.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2022-2024 Karrar Rahim. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
